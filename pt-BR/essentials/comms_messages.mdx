---
title: "Mensagens"
---

## Mensagens

Durante a execução (ou quando o estado da fila muda), o `PromptExecutor` envia mensagens de volta ao cliente
através do método `send_sync` do `PromptServer`.

Essas mensagens são recebidas por um ouvinte de eventos de socket definido em `api.js` (no momento da escrita, por volta da linha 90, ou procure por `this.socket.addEventListener`),
que cria um objeto `CustomEvent` para qualquer tipo de mensagem conhecido e o despacha para quaisquer ouvintes registrados.

Uma extensão pode se registrar para receber eventos (normalmente feito na função `setup()`) seguindo o idioma padrão do Javascript:

```Javascript
api.addEventListener(message_type, messageHandler);
```

Se o `message_type` não for um dos tipos integrados, ele será adicionado automaticamente à lista de tipos de mensagens conhecidos. O `messageHandler` da mensagem
será chamado com um objeto `CustomEvent`, que estende o evento levantado pelo socket para adicionar uma propriedade `.detail`, que é um dicionário dos
dados enviados pelo servidor. Portanto, o uso geralmente segue as linhas de:

```Javascript
function messageHandler(event) {
    if (event.detail.node == aNodeIdThatIsInteresting) {
        // do something with event.detail.other_things
    }
}
```

### Tipos de mensagens integradas

Durante a execução (ou quando o estado da fila muda), o `PromptExecutor` envia as seguintes mensagens de volta ao cliente 
através do método `send_sync` do `PromptServer`. Uma extensão pode se registrar como um ouvinte para qualquer uma dessas.

|event|when|data|  
|-|-|-|
|`execution_start`|Quando um prompt está prestes a ser executado|`prompt_id`|
|`execution_error`|Quando um erro ocorre durante a execução|`prompt_id`, mais informações adicionais|
|`execution_interrupted`|Quando a execução é interrompida por um nó levantando `InterruptProcessingException`|`prompt_id`, `node_id`, `node_type` e `executed` (uma lista de nós executados)|
|`execution_cached`|No início da execução|`prompt_id`, `nodes` (uma lista de nós que estão sendo pulados porque suas saídas em cache podem ser usadas)|
|`executing`|Quando um novo nó está prestes a ser executado|`node` (id do nó ou `None` para indicar conclusão), `prompt_id`|
|`executed`|Quando um nó retorna um elemento ui |`node` (id do nó), `prompt_id`, `output`|
|`progress`|Durante a execução de um nó que implementa o hook necessário|`node` (id do nó), `prompt_id`, `value`, `max`|
|`status`|Quando o estado da fila muda|`exec_info`, um dicionário que segura `queue_remaining`, o número de entradas na fila|

### Usando executado

Apesar do nome, uma mensagem `executed` não é enviada sempre que um nó completa a execução (ao contrário de `executing`), mas apenas quando o nó
retorna uma atualização ui.

Para fazer isso, a função principal precisa retornar um dicionário em vez de uma tupla:

```python
# at the end of my main method
        return { "ui":a_new_dictionary, "result": the_tuple_of_output_values }
```

`a_new_dictionary` será então enviado como o valor de `output` em uma mensagem `executed`. 
A chave `result` pode ser omitida se o nó não tiver saídas (veja, por exemplo, o código para `SaveImage` em `nodes.py`)

### Tipos de mensagens personalizados

Como indicado acima, no lado do cliente, um tipo de mensagem personalizado pode ser adicionado simplesmente se registrando como um ouvinte para um nome único de tipo de mensagem.

```Javascript
api.addEventListener("my.custom.message", messageHandler);
```

No servidor, o código é igualmente simples:
```Python
from server import PromptServer
# then, in your main execution function (normally)
        PromptServer.instance.send_sync("my.custom.message", a_dictionary)
```

#### Obtendo node_id

A maioria das mensagens integradas inclui o id do nó atual no valor de `node`. É provável que você queira fazer o mesmo.

O node_id está disponível no lado do servidor através de uma entrada oculta, que é obtida com a chave `hidden` no dicionário `INPUT_TYPES`:

```Python
    @classmethod    
    def INPUT_TYPES(s):
        return {"required" : { }, # whatever your required inputs are 
                "hidden": { "node_id": "UNIQUE_ID" } } # Add the hidden key

    def my_main_function(self, required_inputs, node_id):
        # do some things
        PromptServer.instance.send_sync("my.custom.message", {"node": node_id, "other_things": etc})
```
